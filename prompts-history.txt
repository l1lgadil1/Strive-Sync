# StriveSync Application Development Summary

## Project Overview
StriveSync is a group self-development challenge platform built with Next.js, TypeScript, and Tailwind CSS. The application allows users to create, join, and track progress on various self-improvement challenges, either individually or as part of teams.

## Current Implementation Status

### Core Pages Implemented:
1. **Home Page**: Landing page with hero section, features, and call-to-action.
2. **Authentication**:
   - Login page with email/password authentication
   - Registration page with form validation using Zod
   - Password recovery functionality

3. **Dashboard**: Personalized user dashboard showing:
   - User statistics
   - Recent activity
   - Active challenges
   - Recommended challenges

4. **Challenges**:
   - Challenges listing page with filtering and search
   - Challenge detail page showing participants, progress, and rules
   - Create challenge form with multi-step wizard

5. **Teams**:
   - Teams listing page with "My Teams", "Invites", and "Discover" tabs
   - Team detail page showing team info, members, challenges, and activity
   - Team creation and management functionality

6. **Leaderboard**:
   - Global and friends leaderboards
   - Filtering by category and time frame
   - Visual indicators for top performers
   - User's current position and stats

7. **Profile**:
   - User profile with editable information
   - Achievement display
   - Activity history
   - Challenge statistics

### UI Components:
- Custom UI components built with Tailwind CSS
- Form components with validation
- Card components for consistent content display
- Navigation components
- Button variants
- Input fields
- Modal dialogs
- Tabs interface
- Progress indicators

### Technical Implementation:
- Next.js App Router architecture
- TypeScript for type safety
- React Server Components where possible
- Client Components for interactive elements
- Responsive design for all screen sizes
- Form validation with React Hook Form and Zod
- Mock data for development

## Pending Features:
1. Backend integration with Spring Boot and PostgreSQL
2. Real-time notifications and chat
3. File upload for challenge proof submission
4. Advanced analytics and reporting
5. Social features like comments and likes
6. Mobile app integration

## Design Principles:
- Clean, modern UI with consistent styling
- Mobile-first responsive design
- Accessible components following WCAG guidelines
- Performance optimization
- Type safety throughout the codebase

## Next Steps:
1. Implement remaining frontend features
2. Develop backend API endpoints
3. Connect frontend to backend
4. Implement authentication flow
5. Add real-time features
6. Conduct testing and optimization

## Project Structure and Code Organization

### Directory Structure
```
/
├── src/
│   ├── app/                      # Next.js App Router pages
│   │   ├── (auth)/               # Authentication routes
│   │   │   ├── login/            # Login page
│   │   │   ├── register/         # Registration page
│   │   │   └── forgot-password/  # Password recovery
│   │   ├── dashboard/            # User dashboard
│   │   ├── challenges/           # Challenge-related pages
│   │   │   ├── [id]/             # Challenge detail page (dynamic route)
│   │   │   └── create/           # Create challenge form
│   │   ├── teams/                # Team-related pages
│   │   │   └── [id]/             # Team detail page (dynamic route)
│   │   ├── leaderboard/          # Leaderboard page
│   │   ├── profile/              # User profile page
│   │   └── page.tsx              # Home page
│   ├── components/               # Reusable components
│   │   ├── layout/               # Layout components
│   │   │   ├── main-layout.tsx   # Main application layout
│   │   │   ├── header.tsx        # Application header
│   │   │   └── footer.tsx        # Application footer
│   │   ├── ui/                   # UI components
│   │   │   ├── button.tsx        # Button component
│   │   │   ├── card.tsx          # Card components
│   │   │   ├── input.tsx         # Input component
│   │   │   ├── textarea.tsx      # Textarea component
│   │   │   ├── label.tsx         # Label component
│   │   │   ├── tabs.tsx          # Tabs component
│   │   │   └── progress.tsx      # Progress component
│   │   ├── auth/                 # Authentication components
│   │   ├── dashboard/            # Dashboard-specific components
│   │   ├── challenges/           # Challenge-specific components
│   │   └── teams/                # Team-specific components
│   ├── lib/                      # Utility functions and helpers
│   │   ├── utils.ts              # General utility functions
│   │   └── validation.ts         # Form validation schemas
│   ├── hooks/                    # Custom React hooks
│   └── types/                    # TypeScript type definitions
├── public/                       # Static assets
└── package.json                  # Project dependencies
```

### Key Implementation Details

#### Page Components
- **Home Page** (`src/app/page.tsx`): Server component with hero section, features, and testimonials.
- **Authentication Pages**:
  - `src/app/(auth)/login/page.tsx`: Client component with login form and validation.
  - `src/app/(auth)/register/page.tsx`: Client component with registration form and Zod validation.
- **Dashboard** (`src/app/dashboard/page.tsx`): Client component with statistics cards and challenge listings.
- **Challenges**:
  - `src/app/challenges/page.tsx`: Client component with filtering and challenge cards.
  - `src/app/challenges/[id]/page.tsx`: Dynamic route for individual challenge details.
  - `src/app/challenges/create/page.tsx`: Multi-step form for creating new challenges.
- **Teams**:
  - `src/app/teams/page.tsx`: Client component with tabs for different team views.
  - `src/app/teams/[id]/page.tsx`: Dynamic route for team details with members and challenges.
- **Leaderboard** (`src/app/leaderboard/page.tsx`): Client component with global and friends rankings.
- **Profile** (`src/app/profile/page.tsx`): Client component with editable user information and statistics.

#### UI Components
- **Layout Components**:
  - `MainLayout` (`src/components/layout/main-layout.tsx`): Wrapper component with header and footer.
  - `Header` (`src/components/layout/header.tsx`): Navigation and user menu.
  - `Footer` (`src/components/layout/footer.tsx`): Links and copyright information.
- **UI Components**:
  - `Button` (`src/components/ui/button.tsx`): Customizable button with variants.
  - `Card` (`src/components/ui/card.tsx`): Content container with header, content, and footer sections.
  - `Input` (`src/components/ui/input.tsx`): Form input field with styling.
  - `Textarea` (`src/components/ui/textarea.tsx`): Multi-line text input.
  - `Label` (`src/components/ui/label.tsx`): Form label component.
  - `Tabs` (`src/components/ui/tabs.tsx`): Tabbed interface for content organization.
  - `Progress` (`src/components/ui/progress.tsx`): Progress indicator for challenges.

#### Data Models
- **User**: Interface for user data with properties like id, name, email, avatar, etc.
- **Challenge**: Interface for challenge data with properties like id, title, description, rules, duration, etc.
- **Team**: Interface for team data with properties like id, name, description, members, challenges, etc.
- **Activity**: Interface for user activity with properties like id, type, date, and related entities.

#### State Management
- Local state with `useState` for component-specific state.
- Form state managed with React Hook Form.
- Validation schemas defined with Zod in `src/lib/validation.ts`.

#### Styling
- Tailwind CSS for utility-based styling.
- Custom UI components with consistent styling.
- Responsive design with mobile-first approach.
- Dark mode support with appropriate color variables.

#### Mock Data
- Mock data for users, challenges, teams, and activities defined in respective page components.
- Structured to mimic API responses for easy backend integration later.

#### TypeScript Integration
- Interfaces for all data models.
- Type annotations for function parameters and return values.
- Strict type checking for component props.

#### Routing
- Next.js App Router for file-based routing.
- Dynamic routes for entity details (challenges, teams).
- Grouped routes for authentication pages.

This structure follows modern Next.js best practices, with a clear separation of concerns and modular components that can be easily maintained and extended.

## Backend Implementation Summary

### System Architecture

#### Backend
- **Framework**: Spring Boot (Java)
- **Database**: PostgreSQL
- **Caching**: Redis, Hibernate second-level cache with JCache/Ehcache
- **Security**: JWT-based authentication
- **API**: RESTful endpoints

### How to Run the Application

#### Backend (Spring Boot)
1. Navigate to the backend directory:
   ```bash
   cd backend
   ```

2. Run the Spring Boot application:
   ```bash
   mvn spring-boot:run
   ```

3. The backend will start on `http://localhost:8080/api`

**Note**: If you encounter the error "No plugin found for prefix 'spring-boot'", make sure you're running the command from the backend directory where the pom.xml file is located.

### Database Configuration

The application uses PostgreSQL with the following configuration:
- **Database**: strivesync
- **Username**: strivesync
- **Password**: strivesync
- **Port**: 5432

### API Endpoints

#### Authentication
- `POST /api/auth/register` - User registration
- `POST /api/auth/login` - User login
- `POST /api/auth/logout` - User logout
- `POST /api/auth/reset-password` - Password reset

#### Challenges
- `GET /api/challenges` - List all challenges
- `GET /api/challenges/{id}` - Get challenge details
- `POST /api/challenges` - Create a new challenge (requires authentication)
- `POST /api/challenges/{id}/join` - Join a challenge (requires authentication)

#### Users
- `GET /api/users/{id}` - Get user profile
- `PUT /api/users/{id}` - Update user profile
- `GET /api/users/{id}/challenges` - Get user's challenges
- `GET /api/users/{id}/achievements` - Get user's achievements

#### Teams
- `GET /api/teams` - List all teams
- `GET /api/teams/{id}` - Get team details
- `POST /api/teams` - Create a new team
- `PUT /api/teams/{id}` - Update team details
- `POST /api/teams/{id}/join` - Join a team

### Backend Structure

#### Main Application
- `backend/src/main/java/com/strivesync/api/StriveSyncApplication.java` - Main application entry point

#### Configuration
- `backend/src/main/resources/application.yml` - Application configuration including database, security, and caching settings

#### Controllers
- `backend/src/main/java/com/strivesync/api/controller/ChallengeController.java` - Handles challenge-related endpoints
- `backend/src/main/java/com/strivesync/api/controller/UserController.java` - Handles user-related endpoints
- `backend/src/main/java/com/strivesync/api/controller/TeamController.java` - Handles team-related endpoints
- `backend/src/main/java/com/strivesync/api/controller/AuthController.java` - Handles authentication endpoints

#### Entities
- `backend/src/main/java/com/strivesync/api/entity/Challenge.java` - Challenge entity with fields like title, description, rules, dates, etc.
- `backend/src/main/java/com/strivesync/api/entity/User.java` - User entity with authentication and profile information
- `backend/src/main/java/com/strivesync/api/entity/Team.java` - Team entity for group challenges
- `backend/src/main/java/com/strivesync/api/entity/Role.java` - Role entity for user permissions
- `backend/src/main/java/com/strivesync/api/entity/Achievement.java` - Achievement entity for gamification
- `backend/src/main/java/com/strivesync/api/entity/ChallengeCompletion.java` - Tracks challenge completions
- `backend/src/main/java/com/strivesync/api/entity/CompletionProof.java` - Stores proof of challenge completions

#### DTOs
- `backend/src/main/java/com/strivesync/api/dto/request/ChallengeRequest.java` - DTO for challenge creation/update
- `backend/src/main/java/com/strivesync/api/dto/response/ChallengeResponse.java` - DTO for challenge responses
- `backend/src/main/java/com/strivesync/api/dto/response/UserSummaryResponse.java` - DTO for user summary information
- `backend/src/main/java/com/strivesync/api/dto/response/MessageResponse.java` - DTO for simple message responses

#### Repositories
- `backend/src/main/java/com/strivesync/api/repository/ChallengeRepository.java` - Repository for challenge data access
- `backend/src/main/java/com/strivesync/api/repository/UserRepository.java` - Repository for user data access
- `backend/src/main/java/com/strivesync/api/repository/RoleRepository.java` - Repository for role data access

#### Security
- `backend/src/main/java/com/strivesync/api/security/JwtAuthenticationFilter.java` - JWT authentication filter
- `backend/src/main/java/com/strivesync/api/security/UserDetailsImpl.java` - Custom user details implementation
- `backend/src/main/java/com/strivesync/api/service/UserDetailsServiceImpl.java` - User details service implementation

### Entity Relationships

- **User-Challenge**: Many-to-many (users can participate in multiple challenges, challenges can have multiple participants)
- **User-Team**: Many-to-many (users can be in multiple teams, teams can have multiple members)
- **Team-Challenge**: Many-to-many (teams can participate in multiple challenges)
- **User-Achievement**: Many-to-many (users can earn multiple achievements)
- **Challenge-ChallengeCompletion**: One-to-many (a challenge can have multiple completions)
- **User-ChallengeCompletion**: One-to-many (a user can complete multiple challenges)
- **ChallengeCompletion-CompletionProof**: One-to-many (a completion can have multiple proofs)

### Challenge Categories and Difficulties

#### Categories
- SPORTS
- READING
- PRODUCTIVITY
- NUTRITION
- MINDFULNESS
- LEARNING
- SOCIAL
- CREATIVITY
- OTHER

#### Difficulties
- BEGINNER
- INTERMEDIATE
- ADVANCED
- EXPERT

### Notes for Development

- The application uses Hibernate second-level caching with JCache/Ehcache for improved performance
- JWT authentication is used for securing API endpoints
- Entity classes use Lombok annotations to reduce boilerplate code
- DTOs are used for data transfer between client and server
- The backend implements RESTful API endpoints following best practices
- Validation is implemented using Jakarta Bean Validation annotations

## API Documentation with Swagger/OpenAPI

The StriveSync API is documented using Swagger/OpenAPI 3.0, which provides interactive API documentation and a testing interface.

### Swagger Configuration

#### Dependencies
The project uses SpringDoc OpenAPI for Swagger integration:

```xml
<dependency>
    <groupId>org.springdoc</groupId>
    <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
    <version>2.3.0</version>
</dependency>
```

#### Configuration Classes
1. **OpenApiConfig.java**: Configures the OpenAPI documentation with API information, server details, and security schemes.

```java
@Configuration
public class OpenApiConfig {
    @Bean
    public OpenAPI openAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("StriveSync API")
                        .description("Backend API for StriveSync - A platform for group self-development challenges")
                        .version("v1.0.0")
                        .contact(new Contact()
                                .name("StriveSync Team")
                                .email("contact@strivesync.com")
                                .url("https://strivesync.com"))
                        .license(new License()
                                .name("MIT License")
                                .url("https://opensource.org/licenses/MIT")))
                .servers(Arrays.asList(
                        new Server().url("http://localhost:8080").description("Development Server"),
                        new Server().url("https://api.strivesync.com").description("Production Server")))
                .components(new Components()
                        .addSecuritySchemes("bearer-jwt", new SecurityScheme()
                                .type(SecurityScheme.Type.HTTP)
                                .scheme("bearer")
                                .bearerFormat("JWT")
                                .in(SecurityScheme.In.HEADER)
                                .name("Authorization")))
                .addSecurityItem(new SecurityRequirement().addList("bearer-jwt"));
    }
}
```

2. **SecurityConfig.java**: Configures security to allow access to Swagger UI and API docs endpoints.

```java
@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {
    // ...
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                // ...
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/auth/**").permitAll()
                        .requestMatchers("/public/**").permitAll()
                        .requestMatchers("/swagger-ui/**", "/swagger-ui.html", "/v3/api-docs/**").permitAll()
                        .anyRequest().authenticated()
                );
        // ...
    }
    // ...
}
```

#### Application Properties
The Swagger UI and API docs are configured in `application.yml`:

```yaml
# Springdoc OpenAPI Configuration
springdoc:
  api-docs:
    path: /v3/api-docs
  swagger-ui:
    path: /swagger-ui
    operationsSorter: method
    tagsSorter: alpha
    filter: true
    displayRequestDuration: true
  show-actuator: false
  default-produces-media-type: application/json
  default-consumes-media-type: application/json
  packages-to-scan: com.strivesync.api.controller
  paths-to-match: /**
```

### Controller Annotations
Controllers are annotated with OpenAPI annotations to provide detailed API documentation:

1. **@Tag**: Groups endpoints by functionality.
2. **@Operation**: Describes each endpoint's purpose and behavior.
3. **@ApiResponses**: Documents possible response codes and their meanings.
4. **@Parameter**: Documents endpoint parameters.
5. **@Schema**: Documents request/response models.

Example:
```java
@RestController
@RequestMapping("/challenges")
@Tag(name = "Challenges", description = "Challenge management API")
public class ChallengeController {

    @GetMapping("/{id}")
    @Operation(summary = "Get challenge by ID", description = "Returns a challenge by its ID")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Successfully retrieved challenge",
                    content = @Content(mediaType = "application/json", 
                    schema = @Schema(implementation = ChallengeResponse.class))),
            @ApiResponse(responseCode = "404", description = "Challenge not found",
                    content = @Content)
    })
    public ResponseEntity<ChallengeResponse> getChallengeById(
            @Parameter(description = "Challenge ID", required = true) @PathVariable Long id) {
        // Implementation
    }
}
```

### Accessing Swagger UI
The Swagger UI is accessible at:
```
http://localhost:8080/api/swagger-ui/index.html
```

The OpenAPI specification is available at:
```
http://localhost:8080/api/v3/api-docs
```

### Using Swagger UI for Testing
1. **Authentication**:
   - Use the `/api/auth/login` endpoint to get a JWT token
   - Click the "Authorize" button at the top of the page
   - Enter your JWT token in the format: `Bearer your_token_here`
   - Click "Authorize" to apply the token to all subsequent requests

2. **Exploring and Testing Endpoints**:
   - Endpoints are grouped by tags (Authentication, Challenges)
   - Click on an endpoint to expand it and see details
   - Fill in the required parameters and click "Execute"
   - View the response status, headers, and body

### Troubleshooting
- If Swagger UI is not accessible, check the context path in `application.yml` and ensure the URL includes this path.
- If security is blocking access, verify the security configuration permits access to Swagger paths.
- If the application port is already in use, either stop the existing process or configure a different port.
